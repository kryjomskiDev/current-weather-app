// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'location_page_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LocationPageStateTearOff {
  const _$LocationPageStateTearOff();

  _LocationPageInital inital() {
    return const _LocationPageInital();
  }

  LocationPageLoading loading() {
    return const LocationPageLoading();
  }

  LocationPageLoaded loaded() {
    return const LocationPageLoaded();
  }
}

/// @nodoc
const $LocationPageState = _$LocationPageStateTearOff();

/// @nodoc
mixin _$LocationPageState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() loading,
    required TResult Function() loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationPageInital value) inital,
    required TResult Function(LocationPageLoading value) loading,
    required TResult Function(LocationPageLoaded value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LocationPageStateCopyWith<$Res> {
  factory $LocationPageStateCopyWith(
          LocationPageState value, $Res Function(LocationPageState) then) =
      _$LocationPageStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$LocationPageStateCopyWithImpl<$Res>
    implements $LocationPageStateCopyWith<$Res> {
  _$LocationPageStateCopyWithImpl(this._value, this._then);

  final LocationPageState _value;
  // ignore: unused_field
  final $Res Function(LocationPageState) _then;
}

/// @nodoc
abstract class _$LocationPageInitalCopyWith<$Res> {
  factory _$LocationPageInitalCopyWith(
          _LocationPageInital value, $Res Function(_LocationPageInital) then) =
      __$LocationPageInitalCopyWithImpl<$Res>;
}

/// @nodoc
class __$LocationPageInitalCopyWithImpl<$Res>
    extends _$LocationPageStateCopyWithImpl<$Res>
    implements _$LocationPageInitalCopyWith<$Res> {
  __$LocationPageInitalCopyWithImpl(
      _LocationPageInital _value, $Res Function(_LocationPageInital) _then)
      : super(_value, (v) => _then(v as _LocationPageInital));

  @override
  _LocationPageInital get _value => super._value as _LocationPageInital;
}

/// @nodoc

class _$_LocationPageInital implements _LocationPageInital {
  const _$_LocationPageInital();

  @override
  String toString() {
    return 'LocationPageState.inital()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _LocationPageInital);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() loading,
    required TResult Function() loaded,
  }) {
    return inital();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
  }) {
    return inital?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) {
    if (inital != null) {
      return inital();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationPageInital value) inital,
    required TResult Function(LocationPageLoading value) loading,
    required TResult Function(LocationPageLoaded value) loaded,
  }) {
    return inital(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
  }) {
    return inital?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (inital != null) {
      return inital(this);
    }
    return orElse();
  }
}

abstract class _LocationPageInital implements LocationPageState {
  const factory _LocationPageInital() = _$_LocationPageInital;
}

/// @nodoc
abstract class $LocationPageLoadingCopyWith<$Res> {
  factory $LocationPageLoadingCopyWith(
          LocationPageLoading value, $Res Function(LocationPageLoading) then) =
      _$LocationPageLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$LocationPageLoadingCopyWithImpl<$Res>
    extends _$LocationPageStateCopyWithImpl<$Res>
    implements $LocationPageLoadingCopyWith<$Res> {
  _$LocationPageLoadingCopyWithImpl(
      LocationPageLoading _value, $Res Function(LocationPageLoading) _then)
      : super(_value, (v) => _then(v as LocationPageLoading));

  @override
  LocationPageLoading get _value => super._value as LocationPageLoading;
}

/// @nodoc

class _$LocationPageLoading implements LocationPageLoading {
  const _$LocationPageLoading();

  @override
  String toString() {
    return 'LocationPageState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LocationPageLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() loading,
    required TResult Function() loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationPageInital value) inital,
    required TResult Function(LocationPageLoading value) loading,
    required TResult Function(LocationPageLoaded value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LocationPageLoading implements LocationPageState {
  const factory LocationPageLoading() = _$LocationPageLoading;
}

/// @nodoc
abstract class $LocationPageLoadedCopyWith<$Res> {
  factory $LocationPageLoadedCopyWith(
          LocationPageLoaded value, $Res Function(LocationPageLoaded) then) =
      _$LocationPageLoadedCopyWithImpl<$Res>;
}

/// @nodoc
class _$LocationPageLoadedCopyWithImpl<$Res>
    extends _$LocationPageStateCopyWithImpl<$Res>
    implements $LocationPageLoadedCopyWith<$Res> {
  _$LocationPageLoadedCopyWithImpl(
      LocationPageLoaded _value, $Res Function(LocationPageLoaded) _then)
      : super(_value, (v) => _then(v as LocationPageLoaded));

  @override
  LocationPageLoaded get _value => super._value as LocationPageLoaded;
}

/// @nodoc

class _$LocationPageLoaded implements LocationPageLoaded {
  const _$LocationPageLoaded();

  @override
  String toString() {
    return 'LocationPageState.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is LocationPageLoaded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() loading,
    required TResult Function() loaded,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? loading,
    TResult Function()? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LocationPageInital value) inital,
    required TResult Function(LocationPageLoading value) loading,
    required TResult Function(LocationPageLoaded value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LocationPageInital value)? inital,
    TResult Function(LocationPageLoading value)? loading,
    TResult Function(LocationPageLoaded value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LocationPageLoaded implements LocationPageState {
  const factory LocationPageLoaded() = _$LocationPageLoaded;
}
